가상DOM 을 사용하는 이유
가상 돔을 이용해 메모리상에서 변경된 부분만 빠르게 찾아내고,
 실제 DOM 조작을 최소화하여 렌더링 성능을 최적화."

v = vue
-> "불필요한 렌더링을 막고,
 바뀐 부분만 골라서 효율적으로 업데이트하기 위해서입니다."
 -> 유지보수용의
 ---
setup(): 모든 것의 시작
ref(): 반응형 데이터 만들기
return: 화면으로 내보내기
HTML에서의 사용 (화면 렌더링)
@click: 이벤트와 함수 동작


 ---

 mount = Vue 를 Dom에 연결해주는것

 ref == 반응형(값변경) 변경시켜줌
 reactive 객체 ref 동일 (반응)

 vue model == 바뀐걸 감지

 {{}} == 보간법 ==

 프록시는 나중에 알아보자
 MVVM 패턴이 적용되어있다


 refernse == 다이나믹 밸류가 "상태가 변할"수 있으니까 계속 참조해라
(Vue 모델이 ref를 계속 참조함)
 -----
 02_attribute-binding
 셋업리턴 마운트 사용


 --
 03_class-binding

  class 는 css로 화면꾸미기 자주하는 속성

  --

  Q .  클래스 사이즈가 들어갔다 나갔다 하느냐



  액션발생 -> 흐름대로 진행

  ----
  04_multi-attribute

  const {createApp, ref} = Vue
  뷰라는 함수에서 {} 안에 두개 꺼네올거다

   createApp().mount('#app');
   여기서 만든객체를 ID가 app이라는 것에 붙이겠다

   createApp({})
   안에 값넣음

   클릭 -> 클릭 핸들러 실행 -> 리저트텍스트 가 바뀌고 -> 리저트텍스트를 참조하는곳이 바뀜



   ----

   05_condition

   v-show 디렉티브
   (숨기다 == 요소는 존재 O, 보이지 않음(display:none) )

   v-if, v-else, v-elfe 디렉티브
   (요소 생성/제거 == 코드상으로 추가 되었다가 삭제되는 모습)

   * template 태그
   (임시로 범위를 지정하는 용도)


   @click == Von

   변할땐 기존 값은 유지되고
   요소만 변한다

   변수는 순서랑 타입만 중요

   상태변수(ref, reactive)
   -> 변경 Virtual DOM(가상돔) 일부변경(업데이트)
   -> DOM 같은 부분 변경

   버츄얼돔에서 요청할때 id를 사용해서 요청 => key속성

컴포넌트를 완전히 다시 렌더링(재생성)하고 싶을 때 key 속성을 사용한다.
key를 쓰지 않으면 Vue가 기존 컴포넌트를 재사용해서 요소만 바뀌고 내부 상태는 유지된다.
-> 효율이나 안전성 측면에서 좋음
-> 다중요소 사용시 반드시 써라

a태그 == 클릭하면 이동

버튼 한번눌렀는데 두번전파되면 버블링
-> @click.stop 하면 역류 방지

---

input 할 상황에는 v-model이용
input == 입력 감지기
(input에 저장된 값은 value에 저장된다)


.trim을 붙이면
글자사이의 공백(띄어쓰기)이 사라진다

아규먼트 는 전달인자
const bubblingFn = () =>  console.log("ㄴㄴss");
이라면
매개변수 bubblingFn인 아규먼트 를넣으면
console.log 반환된다

---
``
옵션과 셀렉은 하나
초기값을 화면에 출력한 상태
셀렉이 값이 바뀌면 ref해당하는 항목이 바뀌어있고
@change이벤트가 실행된다

---

컴포넌트 == 화면을 구성하는 요소

컴포지션은 대부분 셋업으로 대체됨

---
Tick :
가상DOM 이변 경되면 다음틱에 그 변경사항이 DOM에 적용된다

돔 -> 헬로 월드

반응형 변수 수정 -> 다음 틱에 돔에 반영 (비동기)

(아직 다음 틱 X)
변경후 메세지 출력 -> 안녕 세상(변경되지 않은 돔 내용)


await 를 붙여주면
함수 앞에다가 async 을 붙여준다

---
생명주기 ==
setup -> beforeCreate -> created ->
 deforeMount -> mounted -> (rerendering(beforeUpdate -> update))
 -> beforeUnmoiunt -> unmounted

 on == (액션)했을때

Hook 을 라이프사이클에 걸고

--

반응형 변수 - ref, reactive

계산함수
computed
-> 내부에 종속된 re ,reactive 변경시 계산 수행

watch (특정작업수행) 랑 computed (계산작업실행)
둘이 헷갈릴수 있음
 즉 watch 는 반응형 변수를 감시하는것

pre == 미리

post == 나중에

---
   * watchEffect
      - 별도로 감시할 반응형 변수를 지정하지 않고
        모든 반응형 변수를 감지하는 함수



--------
빌드 == 프로그램을 실행 가능상태로 만드는 것
 컴파일(빌드) == 2진수 만들어서 컴퓨터 실행 가능하게 하는것

 latest == 최신버전


jsconfig == 프로그램요소

packege == 프로젝트 요소(그래이들처럼)
---
터미널
확인: 도구 잘 있나 확인하고 (-v)

생성: 새 프로젝트 폴더 만들고 (create)

이동: 그 폴더로 들어가서 (cd)

설치: 필요한 부품 다운받고 (npm i)

시작: 서버 켜기 (npm run dev)

터미널에서 컨트롤 c -> npm run dev
(이거는 뭐하는지 모르겠다)
---

파스칼 케이스(<>) 안에있는
-> .vue 파일 하나가 component의(재사용 가능한 구성(UI==화면)요소) 역할
-> S F C == single file component == 컴포넌트하나가 vue 의 화면요소가 된다

----

다른 컴포넌트를 import하여 상속받아 사용

- props (단방향 통신)
부모 컴포넌트 -> 자식 컴포넌트로 속성전달
자식은 부모껄 사용할수 있게 되지만
수정은 하지 못한다

- defineProps == ()을 정의한다
-> props를 꺼네 쓸려면 사용해야함 (셋업 기본값이 자동으로 import된다)

- Emit(방출하다) (단방향통신)
자식컴포넌트가 이벤트(부모로부터 받은 함수)를 발생시켜서
부모쪽으로 값을 전달할 수 있다
(자식에서 부모쪽으로 상태값변경)
-> (셋업 기본값이 자동으로 import된다)


- provideinject
-> props, emit 보다 편하게 사용가능


- v-bind == 속성에다가 값을 연결시키는것
- v-bind == : 으로 약자 가능

- @ == src폴더- 경로

- @ == 이벤트 헨들러 - <태그 속성>


ref -== 참조되는 값이 볒ㄴ하면

slot == 부모에서 -> 자식에게 컨텐츠를 전달하기 위해 "원하는 위치에 구멍"을 뚫는것
(router 와 유사주의)
-> 자식이 많을때 부모에만 axios 써서 전달 하기 편함 각각쓰는것보다


slo :  부모 -> 자식 (속성)

scoped slot : 자식 -> 부모 (속성)
-> 자식이 표출할 화면을 부모가 대신 만들어 주는것

----

root == 발송담당 , 길

sigle page ->  한 웹페이지에서 종이처럼 쓰고 지우면서 진행하는 어플리케이션
(그전에는 한화면위에 또다른 한화면을 덮어쓰는 구조였음)


Vue Router == 페이지간의 탐색을 쉽게 해주는것

index 는 항상 기본값


Hash == #
을 사용하는 웹에서 보는곳위치 지정해주는 해시기반 라우팅모드

 -  routes: [     // 라우트 매핑 정보를 담은 배열]
        {
            path : '/A',
            name : 'B',
            component : C
            // /A을 입력하면 B 이름의 C 실행할것이다
        }
        ]

        - <nav></nav> == 페이지간의


        RouterLink -> RouterView



location.href="/" ==  웹 관리자모드 콘솔창에 "/" 에다가
이동할 주소적으면 이동함

location.replace="/" == 웹 페이지를 대체하는 것



중첩라우터 == 유지보수, 중복제거에사용
use router, use route

lazy 나중에 기다렷다가 실행

Eager 즉시바로 실행

interceptor로 중간에 가로채서 낵사원하는 대답을 가로챔
